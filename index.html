<!DOCTYPE html>
<meta charset="utf-8">
<style>
@font-face {
    font-family: 'TradeGothic';
    src: url('2CC1A7_1_0.ttf');
}
body {
	background-color: #222222;
} 
</style>
<body>
	<script src= "lib/d3.v3.min.js"></script> 
	<script src = "lib/d3.geo.zoom.js"></script> 
	<script src = "lib/topojson.v1.min.js"></script> 
	<script src = "lib/underscore.js"></script> 
	<script src = "data.js"></script> 
	<script>

	var width = window.innerWidth,
		height = window.innerHeight;

	var baseScale = 300;
	var zoomedScale = 800;
	var canvas = d3.select("body").append("canvas").attr("width", width).attr("height", height).style({
		 position:"absolute",
    	left:"0px",
    	top:"0px"
	}); 

	var tcanvas = document.createElement('canvas');
	var tctx = tcanvas.getContext('2d');

	tcanvas.width = width;
	tcanvas.height = height;
	tctx.textAlign = "end";
	tctx.textBaseline = 'top';
	tctx.font = "21px TradeGothic"; 
	
	var c = canvas.node().getContext("2d");
	var projection = d3.geo.orthographic().scale(baseScale).translate([width / 2, height / 2]).clipAngle(90).precision(0);

	var path = d3.geo.path().projection(projection).context(c);
	var circle = d3.geo.circle();

	var currentSelection;

	var drawData = {};

	var test = 200; 
	
	var getDistanceToHorizon = function(coordinates) {

		return d3.geo.distance(coordinates, [-projection.rotate()[0],projection.rotate()[1]]);

	};


		var counter = 0; 

	var draw = function() {

		//Don't do anything till our data is loaded 
		if (_.isEmpty(drawData)) {
			return;
		}

		c.clearRect(0, 0, width, height);

		//draw background sphere

		c.fillStyle = "#242e3b";
		c.beginPath();
		path({
			type: "Sphere"
		});
		c.fill();

		//fill countries

		_.each(drawData.countries.features, function(country, index) {
			var color = continentColors[country.properties.continent][countryColoring[index]];
			c.fillStyle = color;
			c.beginPath();
			path(country);
			c.fill();
		});

		//draw borders 

		c.strokeStyle = "#163A24";
		c.lineWidth = 0.6;
		c.beginPath();
		path(drawData.borders);
		c.stroke();

		//draw points

		_.each(storyData, function(story) {

			var isCurrentStory = currentSelection && currentSelection.story == story;

			var pointCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 1 : 0.8) + ")";
			var radiusCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.4 : 0.2) + ")";
			var connectionColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.8 : 0.5) + ")";

			_.each(story.countries, function(country) {

				var countryData = story.objects[country];

				if (countryData) {

					c.beginPath();
					path(countryData.pointCircle);

					c.strokeStyle = pointCenterColor;
					c.fillStyle = pointCenterColor;
					c.stroke();
					c.fill();

					c.beginPath();
					path(countryData.radiusCircle);

					c.strokeStyle = radiusCenterColor;
					c.fillStyle = radiusCenterColor;
					c.stroke();
					c.fill();

				}
			});

			var connectors = {
				type: "MultiLineString",
				coordinates: []
			};

			c.beginPath();
			c.lineWidth = 0.2;
			c.strokeStyle = connectionColor;

			var addConnection = function(endpoint0, endpoint1) {
				connectors.coordinates.push([endpoint0, endpoint1]);
			};

			if (story.connectors) {

				_.each(story.connectors, function(connection) {
					var endpoints = connection.split("_");
					addConnection(story.objects[endpoints[0]].center, story.objects[endpoints[1]].center);
				});

			} else {
				_.each(story.countries, function(country, index) {
					for (var i = index + 1; i < story.countries.length; i++) {
						addConnection(story.objects[country].center, story.objects[story.countries[i]].center);
					}
				});
			}

			path(connectors);
			c.stroke();
		});

		//draw label 
		
		if(currentSelection){

			var	currCenter = projection(currentSelection.center);
			tctx.clearRect(0,0,width,height);

			var linesSplit = currentSelection.story.displayName.split("_");
			var styleSplit = linesSplit[0].split("*");;

			tctx.fillStyle="white";
			tctx.fillText(styleSplit[1],300, 0);

			tctx.fillStyle="#ffff00";
			tctx.fillText(styleSplit[0].toUpperCase(),302-tctx.measureText(styleSplit[1]).width, 0);

			if(linesSplit[1]){
				tctx.fillStyle="white";
				tctx.fillText(linesSplit[1],300, 25);
			}

			currCenter[0] -= 330;
			currCenter[1] -= 10;

			c.drawImage(tcanvas, currCenter[0], currCenter[1]);

		}

	};

	d3.json("world.json", function(error, world) {
		if (error) return console.error(error);

		var countries = topojson.feature(world, world.objects.countries);
		drawData.countries = countries;

		drawData.countriesByName = {};

		_.each(countries.features,function(feature){

			drawData.countriesByName[feature.properties["name_long"]] = feature;

		}); 

		_.each(storyData,function(story){

			story.objects = {};

			_.each(story.countries,function(countryName){

				var country = drawData.countriesByName[countryName];

			if (country) {



				var center = d3.geo.centroid(country);

				var hasTuning = story.centerTuning && story.centerTuning[countryName];

				center[0] += hasTuning ? story.centerTuning[countryName].x : 0;
				center[1] += hasTuning ? story.centerTuning[countryName].y : 0;

				story.objects[countryName] = {
					center: center,
					pointCircle: circle.origin(center).angle(1)(),
					radiusCircle: circle.origin(center).angle(3.5)()
				}

			}

			});
		});

		drawData.borders = topojson.mesh(world, world.objects.countries);
		draw();

	});

	var manualRotationActivated;
	var animationRequest;
	var m0;
	var o0;
	var doRotate;

	var currentRotation = [0, 0, 0];
	var manualRotationActivated = false;

	var mouseDown = function() {
		m0 = [d3.event.pageX, d3.event.pageY];
		o0 = projection.rotate();
		manualRotationActivated = true;
		doRotate = false;
		animationRequest = requestAnimationFrame(rotate);
		d3.event.preventDefault();
	};

	var mouseUp = function() {
		doRotate = false;
		manualRotationActivated = false;
		if (m0) {
			m0 = null;
		}
	};

	var mouseMove = function() {

		//Calculate mouseover 

		currentSelection = null; 

		_.each(storyData,function(story){
			_.each(story.objects,function(obj){

				var currCenter = projection(obj.center)
				
				var xdist = Math.abs(currCenter[0] - d3.event.pageX);
				var ydist = Math.abs(currCenter[1] - d3.event.pageY);

				if (xdist <= 20 && ydist <= 20) {
					currentSelection = {
						center: obj.center,
						story: story
					};
				}

			});
		});

		doRotate = true;
		var m1, o1;
		if (m0) {
			m1 = [d3.event.pageX, d3.event.pageY];
			o1 = [o0[0] + (m1[0] - m0[0]) / 4, o0[1] + (m0[1] - m1[1]) / 4];
			o1[1] = Math.min(Math.max(o1[1], -20), 20);
			currentRotation = [o1[0], o1[1], 0];

		}
	};

	var rotate = function() {
		if (manualRotationActivated) {
			redrawPathsOnManualRotation(currentRotation);
			animationRequest = requestAnimationFrame(rotate);
		}
	};


	var redrawPathsOnManualRotation = function(rotation) {
		if (!doRotate) {
			return;
		}
		redrawPathsOnRotation(rotation);
	};

	var redrawPathsOnRotation = function(rotation) {

		currentRotation = rotation;
		projection.rotate(currentRotation);

		draw();
	};

	d3.timer(function(elapsed) {

	
		if (manualRotationActivated) {
			return;
		}

		currentRotation[0] += 0.15;
		redrawPathsOnRotation(currentRotation);

	});

	d3.select("body")
		.on("mousedown", mouseDown)
		.on("mousemove", mouseMove)
		.on("mouseup", mouseUp)
		.on("touchstart", mouseDown)
		.on("touchmove", mouseMove)
		.on("touchend", mouseUp);

	</script>
<body>