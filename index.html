<!DOCTYPE html>
<meta charset="utf-8">
<style>
@font-face {
    font-family: 'TradeGothic';
    src: url('2CC1A7_1_0.ttf');
}
body {
	background-color: #222222;
} 
</style>
<body>
	<script src= "lib/d3.v3.min.js"></script> 
	<script src = "lib/d3.geo.zoom.js"></script> 
	<script src = "lib/topojson.v1.min.js"></script> 
	<script src = "lib/underscore.js"></script> 
	<script src = "lib/hammer.js"></script> 
	<script src = "data.js"></script> 
	<script>

	var width = window.innerWidth,
		height = window.innerHeight;

	var baseScale = 300;
	var currScale = 1; 
	var zoomedScale = 800;

	var pinching = false; 

	var canvas = d3.select("body").append("canvas").attr("width", width).attr("height", height).style({
		 position:"absolute",
    	left:"0px",
    	top:"0px"
	}); 

	var hammertime = new Hammer(d3.select("body").node(), {});

	hammertime.get('pinch').set({ enable: true });
	hammertime.on('pinch', function(e) {
		currScale = e.scale;
		projection.scale(currScale*baseScale);
		draw(); 
	});
	hammertime.on("pinchstart",function(e){
		pinching = true; 
	});
	hammertime.on('pinchend',function(e){
		baseScale = currScale*baseScale;
		currScale = 1; 
		pinching = false; 
	});

	var tcanvas = document.createElement('canvas');
	var tctx = tcanvas.getContext('2d');

	tcanvas.width = width;
	tcanvas.height = height;

	tctx.textAlign = "end";
	tctx.textBaseline = 'top';

	var c = canvas.node().getContext("2d");

	var projection = d3.geo.orthographic().scale(baseScale).translate([width / 2, height / 2]).clipAngle(90).precision(0);

	var path = d3.geo.path().projection(projection).context(c);
	var circle = d3.geo.circle();

	var currentSelection;

	var drawData = {};

	var zoomed = false;
	var inZoom = false; 

	var zoomDirection; 
	var selectedStory; 

	var zoomCounter = 0;
	var ease = d3.ease("quad-in-out");

	var zoom = d3.geo.zoom()
		.projection(projection).on("zoom", function() {
			inZoom = true;
			draw && draw();
			zoomCounter++;
		}).on("zoomend", function() {
			inZoom = false;
			zoomCounter = 0;
			if (zoomDirection == "in") {
				zoomed = true;
			} else {
				zoomed = false;
			}
		});

	canvas.call(zoom.event);

	var draw = function() {

		//Don't do anything till our data is loaded 
		if (_.isEmpty(drawData)) {
			return;
		}

		var currSelect = currentSelection || selectedStory; 

		c.clearRect(0, 0, width, height);

		//draw background sphere

		c.fillStyle = "#242e3b";
		c.beginPath();
		path({
			type: "Sphere"
		});
		c.fill();

		//fill countries

		_.each(drawData.countries.features, function(country, index) {
			var color = continentColors[country.properties.continent][countryColoring[index]];
			c.fillStyle = color;
			c.beginPath();
			path(country);
			c.fill();
		});

		//draw borders 

		c.strokeStyle = "#163A24";
		c.lineWidth = 0.6;
		c.beginPath();
		path(drawData.borders);
		c.stroke();

		//draw points

		_.each(storyData, function(story) {

			if(selectedStory && story != selectedStory.story){
				return; 
			}

			var isCurrentStory = currSelect && currSelect.story == story;

			var pointCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 1 : 0.8) + ")";
			var radiusCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.4 : 0.2) + ")";
			var connectionColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.8 : 0.5) + ")";

			_.each(story.countries, function(country) {

				var countryData = story.objects[country];

				if (countryData) {

					c.beginPath();
					path(countryData.pointCircle);

					c.strokeStyle = pointCenterColor;
					c.fillStyle = pointCenterColor;
					c.fill();

					c.beginPath();
					path(countryData.radiusCircle);

					c.strokeStyle = radiusCenterColor;
					c.fillStyle = radiusCenterColor;
					c.fill();

				}
			});

			var connectors = {
				type: "MultiLineString",
				coordinates: []
			};

			c.beginPath();
			c.lineWidth = 0.2;
			c.strokeStyle = connectionColor;

			var addConnection = function(endpoint0, endpoint1) {
				connectors.coordinates.push([endpoint0, endpoint1]);
			};

			if (story.connectors) {

				_.each(story.connectors, function(connection) {
					var endpoints = connection.split("_");
					addConnection(story.objects[endpoints[0]].center, story.objects[endpoints[1]].center);
				});

			} else {
				_.each(story.countries, function(country, index) {
					for (var i = index + 1; i < story.countries.length; i++) {
						addConnection(story.objects[country].center, story.objects[story.countries[i]].center);
					}
				});
			}

			path(connectors);
			c.stroke();
		});

		//draw label 
		
		if(currSelect && !(inZoom && zoomDirection == "out")){

			//c.font = (17 + ease(zoomCounter / 10) * 6)+"pt TradeGothic"; 

			var	currCenter = projection(currSelect.center);

			c.save(); 

			currCenter[0] -= 30; 
			currCenter[1] -= 15;

			var scale = 1 + ease(zoomCounter / 10); 
			var offset = 135; 

			c.translate(currCenter[0]-(200+offset)*scale - (ease(zoomCounter / 10)) * 25 * scale,currCenter[1]-300*scale);

			c.scale(scale,scale);

			currSelect.story.displayPath && currSelect.story.displayPath(c); 

			c.restore(); 

		}

	};

	d3.json("world.json", function(error, world) {
		if (error) return console.error(error);

		var countries = topojson.feature(world, world.objects.countries);

		cleanCountryData(countries);

		drawData.countries = countries;

		drawData.countriesByName = {};

		_.each(countries.features,function(feature){

			drawData.countriesByName[feature.properties["name_long"]] = feature;

		}); 

		_.each(storyData,function(story){

			story.objects = {};

			_.each(story.countries,function(countryName){

				var country = drawData.countriesByName[countryName];

			if (country) {

				var center = d3.geo.centroid(country);

				var hasTuning = story.centerTuning && story.centerTuning[countryName];

				center[0] += hasTuning ? story.centerTuning[countryName].x : 0;
				center[1] += hasTuning ? story.centerTuning[countryName].y : 0;

				story.objects[countryName] = {
					center: center,
					pointCircle: circle.origin(center).angle(1)(),
					radiusCircle: circle.origin(center).angle(3.5)()
				}

			}

			});
		});

		drawData.borders = topojson.mesh(world, world.objects.countries);
		draw();

	});


	var click = function() {

		if (zoomed) {
			zoomDirection = "out";
			selectedStory = null;
			projection.startingRotation = currentRotation;
			currentRotation = [currentRotation[0], 0, 0];
			projection.scale(baseScale).rotate(currentRotation);
			canvas.transition().ease("quad-in-out").duration(600).call(zoom.projection(projection).event);
		} else if (currentSelection) {
			zoomDirection = "in";
			selectedStory = currentSelection;
			projection.startingRotation = currentRotation;
			currentRotation = [-currentSelection.center[0], -currentSelection.center[1], 0];
			projection.rotate(currentRotation).scale(zoomedScale).translate([width / 2, height / 2]);
			canvas.transition().ease("quad-in-out").duration(600).call(zoom.projection(projection).event);
		}

		zoomed = null;

	};

	var manualRotationActivated;
	var animationRequest;
	var m0;
	var o0;
	var doRotate;

	var currentRotation = [0, 0, 0];
	var manualRotationActivated = false;

	var mouseDown = function() {
		m0 = [d3.event.pageX, d3.event.pageY];
		o0 = projection.rotate();
		manualRotationActivated = true;
		doRotate = false;
		animationRequest = requestAnimationFrame(rotate);
		d3.event.preventDefault();
	};

	var mouseUp = function() {
		doRotate = false;
		manualRotationActivated = false;
		if (m0) {
			m0 = null;
		}
	};

	var mouseMove = function(isTouch) {

		//Calculate mouseover 

		currentSelection = null; 

		if(!inZoom && !isTouch){

			_.each(storyData,function(story){
				_.each(story.objects,function(obj){

					var currCenter = projection(obj.center)
					
					var xdist = Math.abs(currCenter[0] - d3.event.pageX);
					var ydist = Math.abs(currCenter[1] - d3.event.pageY);

					if (xdist <= 20 && ydist <= 20) {
						currentSelection = {
							center: obj.center,
							story: story
						};
					}

				});
			});

		}

		if(pinching){
			return; 
		}

		doRotate = true;
		var m1, o1;
		if (m0) {
			m1 = [d3.event.pageX, d3.event.pageY];
			o1 = [o0[0] + (m1[0] - m0[0]) / 4, o0[1] + (m0[1] - m1[1]) / 4];
			o1[1] = Math.min(Math.max(o1[1], -20), 20);
			currentRotation = [o1[0], o1[1], 0];

		}
	};

	var rotate = function() {
		if (manualRotationActivated) {
			redrawPathsOnManualRotation(currentRotation);
			animationRequest = requestAnimationFrame(rotate);
		}
	};


	var redrawPathsOnManualRotation = function(rotation) {
		if (!doRotate) {
			return;
		}
		redrawPathsOnRotation(rotation);
	};

	var redrawPathsOnRotation = function(rotation) {

		currentRotation = rotation;
		projection.rotate(currentRotation); 
		
		draw();
	};

	d3.timer(function(elapsed) {
	
		if (manualRotationActivated || inZoom || zoomed || pinching) {
			return;
		}

		currentRotation[0] += 0.15;
		redrawPathsOnRotation(currentRotation);

	});

	d3.select("body")
		.on("mousedown", mouseDown)
		.on("mousemove", mouseMove)
		.on("mouseup", mouseUp)
		.on("touchstart", mouseDown)
		.on("touchmove", function(){
			mouseMove(true);	
		})
		.on("touchend", mouseUp)
		.on("click",click);

	</script>
<body>