<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>
<body>
	<script src= "lib/d3.v3.min.js"></script> 
	<script src = "lib/d3.geo.zoom.js"></script> 
	<script src = "lib/topojson.v1.min.js"></script> 
	<script src = "lib/underscore.js"></script> 
	<script src = "data.js"></script> 
	<script>

	var width = window.innerWidth,
		height = window.innerHeight;


	var baseScale = 300;
	var zoomedScale = 800;
	var canvas = d3.select("body").append("canvas").attr("width", width).attr("height", height);

	var c = canvas.node().getContext("2d");

	var projection = d3.geo.orthographic().scale(baseScale).translate([width / 2, height / 2]).clipAngle(90).precision(0.1);

	var path = d3.geo.path().projection(projection).context(c);
	var circle = d3.geo.circle();

	var drawData = {};

	var draw = function() {

		//Don't do anything till our data is loaded 
		if (_.isEmpty(drawData)) {
			return;
		}

		c.clearRect(0, 0, width, height);

		//draw background sphere

		c.fillStyle = "#343534";
		c.beginPath(); 
		path({type: "Sphere"});
		c.fill();


		//fill countries

		_.each(drawData.countries.features, function(country, index) {
			var color = continentColors[country.properties.continent][countryColoring[index]]; 
			c.fillStyle = color;
			c.beginPath();
			path(country);
			c.fill();
		});

		//draw borders 

		c.strokeStyle = "#163A24";
		c.lineWidth = 0.6;
		c.beginPath();
		path(drawData.borders);
		c.stroke();

		//draw points

		_.each(storyData, function(story) {
			var pointCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + 0.8 + ")";
			c.strokeStyle = pointCenterColor;
			c.fillStyle = pointCenterColor; 	
			_.each(story.countries, function(country) {

				var countryFeature = drawData.countriesByName[country];
				if (countryFeature) {

					var centroid = d3.geo.centroid(countryFeature);
					var centerCircle = circle.origin(centroid).angle(1)();

					c.beginPath();
					path(centerCircle);

					c.stroke();
					c.fill();

				/*	fill: storyColors[story],
								stroke: storyColors[story],
								"stroke-opacity": 0.2,
								"fill-opacity": 0.2,*/

				}
			});
		});
	}

	d3.json("world.json", function(error, world) {
		if (error) return console.error(error);

		var countries = topojson.feature(world, world.objects.countries);
		drawData.countries = countries;

		drawData.countriesByName = {};

		_.each(countries.features,function(feature){
			drawData.countriesByName[feature.properties["name_long"]] = feature;
		}); 

		drawData.borders = topojson.mesh(world, world.objects.countries);
		draw();

	});

	var manualRotationActivated;
	var animationRequest;
	var m0;
	var o0;
	var doRotate;

	var currentRotation = [0, 0, 0];
	var manualRotationActivated = false;

	var mouseDown = function() {
		m0 = [d3.event.pageX, d3.event.pageY];
		o0 = projection.rotate();
		manualRotationActivated = true;
		doRotate = false;
		animationRequest = requestAnimationFrame(rotate);
		d3.event.preventDefault();
	};

	var mouseUp = function() {
		doRotate = false;
		manualRotationActivated = false;
		if (m0) {
			m0 = null;
		}
	};

	var mouseMove = function() {
		doRotate = true;
		var m1, o1;
		if (m0) {
			m1 = [d3.event.pageX, d3.event.pageY];
			o1 = [o0[0] + (m1[0] - m0[0]) / 4, o0[1] + (m0[1] - m1[1]) / 4];
			o1[1] = Math.min(Math.max(o1[1], -20), 20);
			currentRotation = [o1[0], o1[1], 0];

		}
	};

	var rotate = function() {
		if (manualRotationActivated) {
			redrawPathsOnManualRotation(currentRotation);
			animationRequest = requestAnimationFrame(rotate);
		}
	};


	var redrawPathsOnManualRotation = function(rotation) {
		if (!doRotate) {
			return;
		}
		redrawPathsOnRotation(rotation);
	};

	var redrawPathsOnRotation = function(rotation) {

		currentRotation = rotation;
		projection.rotate(currentRotation);

		draw();
	};

	d3.timer(function() {

		if (manualRotationActivated) {
			return;
		}

		currentRotation[0] += 0.15;
		redrawPathsOnRotation(currentRotation);

	});

	d3.select("body")
		.on("mousedown", mouseDown)
		.on("mousemove", mouseMove)
		.on("mouseup", mouseUp)
		.on("touchstart", mouseDown)
		.on("touchmove", mouseMove)
		.on("touchend", mouseUp);
	</script>
<body>