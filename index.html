<!DOCTYPE html>
<meta charset="utf-8">
<style>
</style>
<body>
	<script src= "lib/d3.v3.min.js"></script> 
	<script src = "lib/d3.geo.zoom.js"></script> 
	<script src = "lib/topojson.v1.min.js"></script> 
	<script src = "lib/underscore.js"></script> 
	<script src = "data.js"></script> 
	<script>

	var width = window.innerWidth,
		height = window.innerHeight;

	var baseScale = 300;
	var zoomedScale = 800;
	var canvas = d3.select("body").append("canvas").attr("width", width).attr("height", height); 

	var c = canvas.node().getContext("2d");

	var projection = d3.geo.orthographic().scale(baseScale).translate([width / 2, height / 2]).clipAngle(90).precision(0);

	var path = d3.geo.path().projection(projection).context(c);
	var circle = d3.geo.circle();

	var currentSelection;

	var drawData = {};

	var draw = function() {

		//Don't do anything till our data is loaded 
		if (_.isEmpty(drawData)) {
			return;
		}

		c.clearRect(0, 0, width, height);

		//draw background sphere

		c.fillStyle = "#343534";
		c.beginPath();
		path({
			type: "Sphere"
		});
		c.fill();

		//fill countries

		_.each(drawData.countries.features, function(country, index) {
			var color = continentColors[country.properties.continent][countryColoring[index]];
			c.fillStyle = color;
			c.beginPath();
			path(country);
			c.fill();
		});

		//draw borders 

		c.strokeStyle = "#163A24";
		c.lineWidth = 0.6;
		c.beginPath();
		path(drawData.borders);
		c.stroke();

		//draw points

		_.each(storyData, function(story) {

			var isCurrentStory = currentSelection == story;

			var pointCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 1 : 0.8) + ")";
			var radiusCenterColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.4 : 0.2) + ")";
			var connectionColor = "rgba(" + story.color[0] + "," + story.color[1] + "," + story.color[2] + "," + (isCurrentStory ? 0.8 : 0.5) + ")";

			_.each(story.countries, function(country) {

				var countryData = story.objects[country];

				if (countryData) {

					c.beginPath();
					path(countryData.pointCircle);

					c.strokeStyle = pointCenterColor;
					c.fillStyle = pointCenterColor;
					c.stroke();
					c.fill();

					c.beginPath();
					path(countryData.radiusCircle);

					c.strokeStyle = radiusCenterColor;
					c.fillStyle = radiusCenterColor;
					c.stroke();
					c.fill();

				}
			});

			var connectors = {
				type: "MultiLineString",
				coordinates: []
			};

			c.beginPath();
			c.lineWidth = 0.2;
			c.strokeStyle = connectionColor;

			var addConnection = function(endpoint0, endpoint1) {
				connectors.coordinates.push([endpoint0, endpoint1]);
			};

			if (story.connectors) {

				_.each(story.connectors, function(connection) {
					var endpoints = connection.split("_");
					addConnection(story.objects[endpoints[0]].center, story.objects[endpoints[1]].center);
				});

			} else {
				_.each(story.countries, function(country, index) {
					for (var i = index + 1; i < story.countries.length; i++) {
						addConnection(story.objects[country].center, story.objects[story.countries[i]].center);
					}
				});
			}

			path(connectors);
			c.stroke();
		});
	};

	d3.json("world.json", function(error, world) {
		if (error) return console.error(error);

		var countries = topojson.feature(world, world.objects.countries);
		drawData.countries = countries;

		drawData.countriesByName = {};

		_.each(countries.features,function(feature){

			drawData.countriesByName[feature.properties["name_long"]] = feature;

		}); 

		_.each(storyData,function(story){

			story.objects = {};

			_.each(story.countries,function(countryName){

				var country = drawData.countriesByName[countryName];

				var center = d3.geo.centroid(country); 

				var hasTuning = story.centerTuning && story.centerTuning[countryName]; 

				center[0] += hasTuning ? story.centerTuning[countryName].x : 0;
				center[1] += hasTuning ? story.centerTuning[countryName].y : 0;

				story.objects[countryName] = {
					center:center,
					pointCircle:circle.origin(center).angle(1)(),
					radiusCircle:circle.origin(center).angle(3.5)()
				}

			});
		});

		drawData.borders = topojson.mesh(world, world.objects.countries);
		draw();

	});

	var manualRotationActivated;
	var animationRequest;
	var m0;
	var o0;
	var doRotate;

	var currentRotation = [0, 0, 0];
	var manualRotationActivated = false;

	var mouseDown = function() {
		m0 = [d3.event.pageX, d3.event.pageY];
		o0 = projection.rotate();
		manualRotationActivated = true;
		doRotate = false;
		animationRequest = requestAnimationFrame(rotate);
		d3.event.preventDefault();
	};

	var mouseUp = function() {
		doRotate = false;
		manualRotationActivated = false;
		if (m0) {
			m0 = null;
		}
	};

	var mouseMove = function() {

		//Calculate mouseover 

		currentSelection = null; 

		_.each(storyData,function(story){
			_.each(story.objects,function(obj){

				var currCenter = projection(obj.center)
				
				var xdist = Math.abs(currCenter[0] - d3.event.pageX);
				var ydist = Math.abs(currCenter[1] - d3.event.pageY);

				if(xdist <= 20 && ydist <= 20){
					currentSelection = story; 
				}

			});
		});

		doRotate = true;
		var m1, o1;
		if (m0) {
			m1 = [d3.event.pageX, d3.event.pageY];
			o1 = [o0[0] + (m1[0] - m0[0]) / 4, o0[1] + (m0[1] - m1[1]) / 4];
			o1[1] = Math.min(Math.max(o1[1], -20), 20);
			currentRotation = [o1[0], o1[1], 0];

		}
	};

	var rotate = function() {
		if (manualRotationActivated) {
			redrawPathsOnManualRotation(currentRotation);
			animationRequest = requestAnimationFrame(rotate);
		}
	};


	var redrawPathsOnManualRotation = function(rotation) {
		if (!doRotate) {
			return;
		}
		redrawPathsOnRotation(rotation);
	};

	var redrawPathsOnRotation = function(rotation) {

		currentRotation = rotation;
		projection.rotate(currentRotation);

		draw();
	};

	d3.timer(function() {

		if (manualRotationActivated) {
			return;
		}

		currentRotation[0] += 0.15;
		redrawPathsOnRotation(currentRotation);

	});

	d3.select("body")
		.on("mousedown", mouseDown)
		.on("mousemove", mouseMove)
		.on("mouseup", mouseUp)
		.on("touchstart", mouseDown)
		.on("touchmove", mouseMove)
		.on("touchend", mouseUp);

	</script>
<body>